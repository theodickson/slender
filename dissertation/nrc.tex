\chapter{Nested Relational Calculus} \label{nrc}

In this chapter we explain the variant of the nested relational calculus used in this work.
First we explain how its semantics allow arbitrary nesting of collections, and introduce the core algebraic operators, showing how they enable a wide range of queries. Then we introduce some syntactic constructions which allow us to more naturally express nested queries. We explain the two forms that nested queries can take (key-nested and value-nested), and why the former is preferable semantically but not efficiently parallelised or incrementalised. Next we introduce the delta expressions for each operator, and show that while most operators incrementalise efficiently due to their algebraic properties, others must be recomputed with each update. Finally we provide a full description of the shredding transformation, and show how it allows us to simulate the semantics of a single key-nested query with a set of value-nested queries, thus retaining the performance benefits of value-nesting.


\section{Type system} {

In order to apply the shredding operation outlined in the previous chapter, we introduce a variant of the nested relational calculus which uses \textit{generalised multiset semantics}. As opposed to a regular multiset, or \textit{bag}, in which each element in a set is associated with an integer value, in our generalised multiset semantics we model collections by mappings $ \coll{\K}{\R} $ where values can be of any type which admits a ring structure $ (\R,0_\R,+_\R,-_\R,1_\R,*_\R) $. In the following we will show the two key properties of these semantics. Firstly, that they admit nesting of collections to arbitrary depth, and secondly, that they give rise to the potential for efficient incrementalisation and parallelisation since the majority of the operators we will introduce are distributive ring operations.

Figure \ref{nrctypes} formally describes the type system that enables these semantics, using an inductive definition.

\begin{figure}
\begin{equation*}
\begin{aligned}
&\R := \prim{Int} \OR \prim{Bool} \OR \R \times  \R \OR \coll{\K}{\R} \\
&\K := \prim{Dom} \OR  [\R]  \OR \prim{Label} \\
\end{aligned}
\qquad
\begin{aligned}
\end{aligned}
\end{equation*}
\caption{The type system of the NRC}
\label{nrctypes}
\end{figure}

It will also be useful to introduce the notation $\Bag{\K} := \coll{\K}{\prim{Int}}$, for collections with integer multiplicity.

\subsection{Ring types} {
The base cases of our ring type are the integers and the booleans. Integers admit the ring structure $(\mathbb{Z},0,+,-,1,*)$, and booleans the structure $(\mathbb{B}, false,OR,NOT,true,AND)$. Note that it is trivial to extend this calculus to other primitive types admitting a ring structure, such as the real numbers, but for brevity we omit these. 

The first of our inductive cases is the product type $\R \times \R$. A product of two ring types $\R_1$ and $\R_2$ trivially admits a ring structure by pairing the 0 and 1 elements and applying the operations of $\R_1$ and $\R_2$ element-wise. Although in practice we will be able to use tuples of any arity, in this formalism we only define operations for a pair, as higher arities are isomorphic to nesting products within the second element.

The second and crucial inductive case is the collection type $\coll{\K}{\R}$, which itself admits a ring structure in which $\R$'s operations are applied element-wise over the key space $\K$. For example, if we have two collections $X: \coll{\K}{\R}$ and $Y: \coll{\K}{\R}$ then:

\begin{equation*}
\begin{split}
& (X+Y)(k)  = X(k) +_\R Y(k) \\
& (X*Y)(k) = X(k) *_\R Y(k)
\end{split}
\end{equation*}

If $\R$ is an $\prim{Int}$, so that $X,Y: \Bag{\K}$, then we can see that $+$ corresponds to bag union. We can also see that $*$ is thus join-like when applied to collections - a key will only have non-zero value in the resulting collection if it has non-zero value in each of $X$ and $Y$. In this way, we equate the existence of a key with it having non-zero value. Hence the zero element $0_{\coll{\K}{\R}}$, which is the empty collection, is equivalent to the collection where every $k \in \K$ is mapped to the zero element $0_R$. This underlines the incrementalisation potential of this algebraic framework, as it means deletions can be modelled with updates to keys with negative value.

Thus, can use collections themselves as multiplicities. For example, a collection of type $\coll{\K_1}{(\coll{\K_2}{\R})}$ associates a collection of type $\coll{\K_2}{\R}$ to each key of type ${\K_1}$. This is what we call \textit{value} or \textit{ring} nesting and is the first way to obtain nested collections.

\subsection{Key types} {

For keys, the base types are the $\prim{Dom}$ types. These are the types of the active domain of the database. When using Apache Spark for example, this constitutes all serializable Scala data types. In a typical relational database this would be much more restricted, to types such as INT, FLOAT, VARCHAR, TIMESTAMP, and so on. 

The type $[\R]$ (the boxed ring type) offers ring types for use as keys while retaining the view of their ring structure, thus marking the places where shredding can be performed. For example, a collection of type $\coll{(\K_1,[\coll{\K_2}{\R}])}{\prim{Int}}$ maps a pair of two key types, $\K_1$ and the boxed ring type, $[\coll{\K_2}{\R}]$ to a multiplicity of $\prim{Int}$ type. This is what we call \textit{key nesting}. 

The $\prim{Label}$ type represents places we have applied shredding, in order to replace key-nested collections with labels. For example, in a query which produces a result of type  $\coll{(\K_1,[\coll{\K_2}{\R}])}{\prim{Int}}$, we would expect shredding to instead produce a result of type 
$\coll{(\K_1,\prim{Label})}{\prim{Int}}$, along with a dictionary of type $\coll{\prim{Label}}{(\coll{\K_2}{\R})}$. Note that both of these types do not contain key-nested collections. Instead our dictionary uses value-nesting. This will be crucial to how we efficiently incrementalise such shredded queries.

}

\section{Expressions} \label{nrcexprsection}

Figure \ref{nrcexprs} introduces the constructions that define the valid expressions in our calculus. In this section we explain these and discuss their algebraic properties.

\begin{figure}
\begin{equation*}
\begin{split}
k := \ & c \OR x \OR \langle k_1, k_2 \rangle \OR \proj{k}{i} \\ \\
r := \ & c \OR X \OR \langle r_1, r_2 \rangle \OR \proj{r}{i} \OR \\
& r_1 + r_2 \OR -r \OR r_1 \ast r_2 \OR r_1 \cdot r_2 \OR \\
& join(r_1,r_2) \OR sum(r) \OR p(k) \OR \\
& sng(k,r) \OR \{ x => r \} \OR group(r)
\end{split}
\end{equation*}
\caption{Valid expressions in the NRC.}
\label{nrcexprs}
\end{figure}

\subsection{Ring expressions} {
The base expressions of ring type are constants and input collections, denoted by $c$ and $X$ respectively. Constants will be of $\prim{Int}$ or $\prim{Bool}$ type in this restricted formalism, but in practice can be of any numeric type or other primitive type admitting a ring structure. Input collections are datasets of type $\coll{\K}{\R}$, where $\K$ is any valid key type and $\R$ any valid ring type. For example, in our motivating example, the input collection \textit{ratings} is of type $\coll{(User \times Track \times Date)}{\prim{Int}}$. We also have a standard tupling operator denoted by $\langle , \rangle$ and can project such product types using the notation $\proj{r}{i}$.

Next we have $+$, $-$, and $\ast$, the algebraic operators defined by the ring structure of $\R$. It will be important when discussing incrementalisation and parallelisation to note that  $\ast$ is distributive with respect to $+$:
\[
a*(b + c) = a*b + a*c.
\]

The dot product ($\cdot$) is a generalised multiplication operator which accepts any two arguments of ring type. It is defined using $*$ as follows:
\begin{equation*}
\begin{split}
& \textrm{If } X: \prim{Int}, \ Y: \prim{Int}\textrm{, then } X \cdot Y = X * Y \\ \\
& \textrm{If } X: \coll{\K}{\R}, \ Y: \prim{Int}\textrm{, then } X \cdot Y : \coll{\K}{\R \cdot \prim{Int}}, \\
& (X \cdot Y)(k) = X(k) \cdot Y\textrm{, for all }k: \K \\ \\
& \textrm{If } X: \coll{\K_1}{\R_1}, \ Y: \coll{\K_2}{\R_2}\textrm{, then } X \cdot Y : \coll{\langle \K_1, \K_2 \rangle}{\R_1 \cdot \R_2} \\
& (X \cdot Y)(\langle k_1, k_2 \rangle) = X(k_1) \cdot Y(k_2)\textrm{, for all }k_1,k_2: \K
\end{split}
\end{equation*}
This operation can natively implement certain useful operations. For example, the dot product of a $\Bag{\K_1}$ and a $\Bag{\K_2}$ produces their cartesian product.

The dot product is distributive:
\vs\begin{equation*}
\begin{split}
& \textrm{If } X: \prim{Int}, \ Y: \prim{Int}\textrm, \ Z: \Int: \\
&X \cdot (Y + Z) = X * (Y + Z) = X*Y + X*Z = X \cdot Y + X \cdot Z \\ \\
& \textrm{If } X: \coll{\K}{\R}, \ Y: \prim{Int}, \ Z: \Int: \\
& (X \cdot (Y+Z))(k) = X(k) \cdot (Y+Z) = X(k) \cdot Y + X(k) \cdot Z = (X \cdot Y)(k) + (X \cdot Z)(k) \\ \\
& \textrm{If } X: \coll{\K_1}{\R_1}, \ Y: \coll{\K_2}{\R_2}, \ Z: \coll{\K_2}{\R_2} \\
& (X \cdot (Y+Z))(\langle k_1, k_2 \rangle) = X(k_1) \cdot (Y+Z)(k_2) = X(k_1) \cdot Y(K_2) + X(k_1) \cdot Z(k_2) \\
&= (X \cdot Y)(k_1) + (X \cdot Z)(k_2) 
\end{split}
\end{equation*}
It also allows us to extend the native ring multiplication operation to collections of the same key type but differing ring types, by defining the output value of each key as the dot product of the values of the key in each input collection:
\begin{equation*}
\begin{split}
& X: \coll{\K}{\R_1}, \ Y: \coll{\K}{\R_2} \\
& X * Y : \coll{\K}{\R_1 \cdot \R_2} \\
& (X*Y)(k) = X(k) \cdot Y(k)
\end{split}
\end{equation*}
We will see in \ref{forcomp} how this extension to multiplication allows us to define a for-comprehension construct with very natural semantics.

As previously mentioned, the $*$ operator can be described as join-like. However, even with this generalisation, it is not general enough to model many useful joins since it joins on the entire key. Thus we introduce a separate join operator, which only operates on collections, and joins only on the first element of a product-typed key. It is defined as follows:
\begin{equation*}
\begin{split}
& X: \coll{(\K,\K_1)}{\R_1},  Y: \coll{(\K,\K_2)}{\R_2} \\
& join(X, Y): \coll{(\K, (\K_1,\K_2))}{\R_1 \cdot \R_2} \\
& join(X, Y)(\langle k, \langle k_1, k_2 \rangle \rangle) = X(\langle k, k_1 \rangle) \cdot Y(\langle k, k_2 \rangle)
\end{split}
\end{equation*}
Thus, a key $\langle k, \langle k_1, k_2 \rangle \rangle$ will only be non-zero in the output if $\langle k, k_1 \rangle$ is non-zero in $X$ and $\langle k, k_2 \rangle$ is non-zero in $Y$. Equivalently, there will be a key  $\langle k, \langle k_1, k_2 \rangle \rangle$ in the output for every pair of keys $\langle k, k_1 \rangle \in X$ and $\langle k', k_2 \rangle \in Y$ such that $k == k'$. Hence, it models an inner join on the first element of the key. It is general enough to model all inner joins if we restructure the elements of a higher arity key as a pair where the element(s) we wish to join on constitute the first element of the key and the others are nested within the second element. 

\noindent The $join$ operator is also distributive:
\begin{equation*}
\begin{split}
&X: \coll{(\K,\K_1)}{\R_1},  \ Y: \coll{(\K,\K_2)}{\R_2}, \ Z: \coll{(\K,\K_2)}{\R_2} \\
&join(X,Y+Z)(\pair{k}{\pair{k_1}{k_2}}) = X(\pair{k}{k_1}) \cdot (Y+Z)(\pair{k}{k_2}) \\
&=X(\pair{k}{k_1}) \cdot Y(\pair{k}{k_2}) + X(\pair{k}{k_1}) \cdot Z(\pair{k}{k_2}) \\
&=join(X,Y)(\pair{k}{\pair{k_1}{k_2}}) + join(X,Z)(\pair{k}{\pair{k_1}{k_2}})
\end{split}
\end{equation*}

The sum operator is another which will be used in the for-comprehension construct, and is defined as follows: 
\begin{equation*}
\begin{split}
 & X: \coll{\K}{\R} \\
 & sum(X): \R \\
 & sum(X) = \sum_{k: K} X(k)
\end{split}
\end{equation*}
It is only defined for collection types, and, for example, when applied to a bag returns its aggregate count.
 
\vs The predicate operator $p(k)$ encapsulates any function accepting a key and returning a boolean. We will see how it enables us to do things such as filter collections.
 
\vs The \textit{singleton} constructor is $sng$. With $k: \K$ and $r: \R$, $sng(k,r)$ constructs a collection of type $\coll{\K}{\R}$ with the single element $k  \mapsto r$. We will see how this combines with our for-comprehension to more generally transform collections.
 
\vs The infinite mapping $\{x => r\}$ allows us to express functions from key types to value types as collections of infinite domain, where the key is a variable expression $x$ and the value is a ring expression $r$ which may use the variables introduced in $x$. When such an expression is multiplied with a finite collection, the variable expression is bound to each of the keys in the finite collection in order to produce a concrete result.

The following example shows us how this allows transformations of finite collections:

\noindent Let $k_1,k_2: K$ be variables. Let $X: \Bag{\K \times \K}$. Let $p(\langle k_1, k_2 \rangle) = k_1 == k_2$ be the predicate comparing $k_1$ and $k_2$ for equality. \\
Let $Y = X * \{\langle k_1, k_2 \rangle => p(\langle k_1, k_2 \rangle)\}$. \\ Applying the definition of *, and assuming $k_1,k_2$ are in the domain of $X$: \\
\begin{equation*}
\begin{split}
Y(\langle k_1, k_2 \rangle) &= X(\pair{k_1}{k_2}) \cdot 1 = X(\pair{k_1}{k_2})\textrm{, if } k_1 == k_2 \\
&= X(\pair{k_1}{k_2}) \cdot 0 = 0\textrm{, otherwise}
\end{split}
\end{equation*}
Hence $Y$ is X filtered to only those keys whose first and second elements are equal.

\vs The last ring-typed construct is group, and is the operator which constructs key-nested collections. It is defined on collections with keys of pair type, as follows:
\begin{equation*}
\begin{split}
&X: \coll{(\K_1 \times \K_2)}{\R} \\
&group(X): \coll{(\K_1 \times [\coll{\K_2}{\R}])}{\prim{Bool}} \\
&group(X)(\pair{k_1}{k_2'}) = true \iff k_2' = \sum_{(\pair{k_1'}{k_2} \mapsto r) \in X : \ k_1' = k_1} {\{k_2 \mapsto r\}} 
\end{split}
\end{equation*}
This creates a key in the output for each unique first element of the key in the input. These keys are paired with the boxed collection of all of the second elements they appear with in the input. In this way it is a grouping of the input by the first element of the key. For example:
\begin{equation*}
\begin{split}
&X: \Bag{\prim{String}\times \prim{String}} \\
&X = \{(a,b) \mapsto 1, (a, c) \mapsto 2, (b,d) \mapsto 3\} \\
&group(X) = \{\langle a, \{b \mapsto 1, c \mapsto 2\} \rangle \mapsto true, \langle b, \{d \mapsto 3 \} \rangle \mapsto true \}
\end{split}
\end{equation*}
This key-nested representation offers an important semantic benefit. It allows us to keep track of keys of type $\K_1$ whose nested collections become empty upon updates to the inputs of the query. Using the example above, suppose we receive an update to $X$:
\begin{equation*}
\dX = \{(\pair{b}{d} \mapsto -3\}
\end{equation*}
This translates to updating the key-nested collection $\pair{b}{\{d \mapsto 3\}}$:
\begin{equation*}
 \pair{b}{\{d \mapsto -3, d \mapsto 3\}} = \pair{b}{\{\}}
 \end{equation*}
However the entry $\pair{b}{\{\}} \mapsto true$ remains in the output, indicating that the inner collection keyed by $b$ exists but is empty.
Letting $group^v(X)$ be the value-nested representation of $group(X)$:
\begin{equation*}
group^v(X) = \{a \mapsto \{b \mapsto 1, c  \mapsto 2\}, b \mapsto \{d \mapsto 3\}\}
\end{equation*}
When we update this with $\{b \mapsto \{d \mapsto 3\}\}$, we get:
\begin{equation*}
group^v(X) = \{a \mapsto \{b \mapsto 1, c  \mapsto 2\}, b \mapsto \{d \mapsto 0\}\} = \{a \mapsto \{b \mapsto 1, c  \mapsto 2\}\}
\end{equation*}
And so $b$ disappears from the top-level of our output entirely. 

\subsection{Key expressions} {
The base key expressions are either constants, denoted $c$, or variables, denoted $x$, which are strictly those introduced as the keys of an infinite mapping. As with ring expressions, we also have tupling and projection. 
}

\section{For-comprehension syntax} { \label{forcomp}
In this section we introduce several variants of a familiar syntactic construction, the for-comprehension, which will allow many queries to be written more naturally.

Let $X$ be a finite collection of type $\coll{\K}{\R}$, $r_1$ be a ring expression of type $\R_1$, and $x$ be a variable of type $\K$. Our basic for-comprehension syntax is thus defined as:
\begin{equation*}
\For{x}{X} \Collect{r_1} := sum(X * \{x => r_1\})
\end{equation*}
It is helpful to think of this as iterating over the key-value pairs $\pair{k}{r}$ in $X$, calculating the value of $r_1$ for each key $k$, and aggregating the result of multiplying this with $r$. For example, with $X: \Bag{\Int}$, the query:
\begin{equation*} 
\For{x}{X} \Collect{x > 2} = sum(X * \{x => x > 2\})
\end{equation*}
calculates the aggregate count of the keys in $X$ which are greater than 2, since:
\begin{equation*}
\begin{split}
(X*\{x => x > 2\})(y) &= X(y)*true = X(y)\textrm{, if } y > 2 \\
 &= X(y)*false = 0\textrm{, otherwise.}
\end{split}
\end{equation*}
We now add a variant of this which enables filtering collections with a natural syntax. With $p(x)$ a predicate expression:
\begin{equation*}
\ForIf{x}{X}{p(x)} \Collect{x > 2} := sum(X * \{x => r_1 \cdot p(x) \})
\end{equation*}
Hence, we can instead write the above query as:
\begin{equation*}
\begin{split}
\ForIf{x}{X}{x > 2} \Collect{1} &= sum(X * \{x => 1 \cdot (x > 2) \}) \\
&=sum(X * \{x => x > 2) \}
\end{split}
\end{equation*}
These examples are quite limited in that they are only aggregations of a collection $X$. In order to transform $X$ more generally, we can use the singleton constructor. For example, consider the following query:
\begin{equation*}
\begin{split}
&X: \coll{(\K_1 \times \K_2)}{\R} \\
&Y = \For{\pair{k_1}{k_2}}{X} \Collect{sng(\pair{k_2}{k_1}, 1)}
\end{split}
\end{equation*}
Then $Y$ is $X$ but with the pairs reversed. To see how this works, let's examine the translation of $Y$ into basic syntax: 
\[ Y = sum(X*\{\pair{k_1}{k_2} => sng(\pair{k_2}{k_1},1)\}) \]
The inner expression $X*\{\pair{k_1}{k_2} => sng(\pair{k_2}{k_1},1)\}$ iterates over $X$ and and maps each key $\pair{k_1}{k_2}$ to its original value, multiplied by $sng(\pair{k_2}{k_1},1)$. Thus, suppose $X = \{\pair{a}{b} \mapsto 1, \pair{c}{d} \mapsto 2\}$, then:
\begin{equation*}
X*\{\pair{k_1}{k_2} => sng(\pair{k_2}{k_1},1)\} = \{(a,b) \mapsto \{(b,a) \mapsto 1\}, (c,d) \mapsto \{(d,c) \mapsto 2\}\}
\end{equation*}
Then the sum outside this aggregates all of the values via bag union, to produce the single flat collection:
\begin{equation*}
\{(b,a) \mapsto 1, (d,c) \mapsto 2\}
\end{equation*}
Which is indeed $X$ with the elements of the keys reversed. We encapsulate this construct with the following variant of our for-comprehension: 
\begin{equation*}
\begin{split}
\ForIf{x}{X}{p(x)} \Yield{k \mapsto r} &:= \ForIf{x}{X}{p(x)} \Collect{sng(k,r)} \\
& \ = sum(X * \{x => sng(k,r \cdot p(x)) \})
\end{split}
\end{equation*}
The $r$ is optional and defaults to 1. Thus, we can write the above query to reverse the elements in a product-type key as:
\[\For{\pair{k_1}{k_2}}{X} \Yield{\pair{k_2}{k_1}}\]
This is clearly a very natural syntax with which to manipulate collections corresponding to similar syntax in many programming languages.

\subsection{Example query} \label{examplequery}

With the for-comprehension syntax, we can now express the query from the motivating example. The \lin{ratings} RDD can be represented by a $\Bag{\prim{User} \times \prim{Track} \times \prim{Date}}$, where the $\Int$ values are the rating given to the track by the given user on the given date. The association table is a $\Bag{\prim{Track} \times \prim{Artist}}$, where the values are all 1. Then the query is:
\begin{equation*}
\begin{split}
&trackRatings = group(\For{\langle u,t,d \rangle}{ratings} \Yield{\pair{t}{d}}) \\
&artistTrackRatingsFlat = join(trackArtists,trackRatingsByDate) \\
&artistTrackRatings = group( \For{\langle t,\langle a,rs \rangle \rangle}{artistTrackRatingsFlat} \Yield{\langle a, \langle t,rs \rangle \rangle})
\end{split}
\end{equation*}

Here, $trackRatings$ first projects the ratings to just the track and date, thus aggregating for each such pair the total rating across all users. It then groups this by track, returning a $\coll{(\prim{Track} \times [\Bag{\prim{Date}}])}{\prim{Bool}}$, representing the pairing of each track with its aggregate rating for each date. Then this is joined with the track association table, which adds the artist to each key, producing a $\coll{(\prim{Track} \times (Artist \times [\Bag{\prim{Date}}]))}{\prim{Bool}}$. Finally, $artistTrackRatings$ reorders the elements of the key with a for/yield so that the artist is the first element, and applies group in order to produce the final
$\coll{(\prim{Artist} \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}])}{\prim{Bool}}$. This collection will have one key per artist, where the artist is the first element, and the collection of ratings for each track on each day is nested within the second element.
}

\section{Restricted construction of key-nested collections}
The $group$ operator is the only way in this calculus to construct key-nested collections. We recognise that this is quite restrictive. In fact, in \cite{draftpaper}, the variant of the NRC used does not include this construct, but instead uses a more general construct $toK$ which boxes arbitrary sub-queries of ring type. Unfortunately, although this allows for a more general query language, the queries written in this way proved highly impractical to implement within Spark. For example, to express the grouping of a collection $X: \Bag{\K_1 \times \K_2}$ by the first element of the key, the following query would be used:
\begin{equation*}
\begin{split}
&\For{\pair{k_1}{k_2}}{X} \\
&\Yield{\pair{k_1}{toK(\ForIf{\pair{k_1'}{k_2'}}{X}{k_1 == k_1'} \Yield k_2')}}
\end{split}
\end{equation*}
Here, the logic to group is expressed by a nested iteration, filtered by a predicate to test for equality of the inner key with the outer key.
The naive way to implement the evaluation of such a query would lead to physically performing this nested iteration, which is clearly very inefficient compared to implementing it with a grouping primitive. Further, in Spark, nested iteration of RDDs is not supported at all.
Thus, without a dedicated optimiser to examine these queries and detect when nested iterations filtered by predicated correspond to grouping or other primitives, it is not possible evaluate such queries in Spark.

Hence it was decided to forego this operator in favour of the explicit $group$ operator which can be directly evaluated using the \lin{groupBy} method on an RDD, as we will see in Chapter \ref{evaluation}.
Despite this, we will see in Chapter \ref{results} that even with this restriction we are still able to express a wide range of complex queries. 

}

\section{Incremental updates to queries} { \label{deltas}



In this section we introduce \textit{delta expressions}, or expressions which compute the update to a query given an update to its inputs. For example, if we have some expression $r$ with an input collection $X$, and receive an update $\delta X$ for $X$ such that the new value of $X$ is $X^{new} = X + \delta X$, the delta expression $\delta_X(r)$ is the expression such that $r^{new}$ = $r + d_X(r)$.

\begin{figure}
\begin{equation*}
\begin{aligned}
&\delta_X(c) = 0 \qquad \delta_X(X) = \Delta X \qquad \delta_X(Y) = 0\\
&\delta_X(\pair{r_1}{r_2}) = \pair{\delta_X(r_1)}{\delta_X(r_2)} \qquad \delta_X(\proj{r}{i}) = \proj{\delta_X(r)}{i}\\
&\delta_X(r_1 + r_2) = \delta_X(r_1) + \delta_X(r_2) \qquad \delta_X(-r) = -\delta_X(r)\\
&\delta_X(r_1 * r_2) = \delta_X(r_1)*r_2 + r_1*\delta_X(r_2) + \delta_X(r_1) * \delta_X(r_2) \\
&\delta_X(r_1 \cdot r_2) = \delta_X(r_1) \cdot r_2 + r_1 \cdot \delta_X(r_2) + \delta_X(r_1) \cdot \delta_X(r_2) \\
&\delta_X(join(r_1,r_2)) = join(\delta_X(r_1),r_2) + join(r_1,\delta_X(r_2)) + join(\delta_X(r_1),\delta_X(r_2)) \\
&\delta_X(sum(r)) = sum(\delta_X(r)) \qquad \delta_X(\{x => r\}) = \{x => \delta_X(r)\} \\
&\delta_X(sng(k,r)) = sng(e^{new},r)  + sng(e^{new},\delta_X(r)) - sng(e^{old},r) \\
&\delta_X(group(r)) = group(r + \delta_X(r)) - group(r)
\end{aligned}
\qquad
\end{equation*}
\caption{Delta derivation rules for NRC expressions.}
\label{deltaexprs}
\end{figure}

Figure \ref{deltaexprs} shows these expressions. The fact that the updates are modelled with addition allows us to exploit the algebraic properties of the operators to derive efficient delta expressions in the majority of cases. For example, we exploit the linearity of $+$ to derive the delta rule:
\[\delta_X(r_1 + r_2) = \delta_X(r_1) + \delta_X(r_2)\]
since: 
\[r_1^{new} + r_2^{new} = (r1 + \delta_X(r_1)) + (r2 + \delta_X(r_2)) = (r_1 + r_2) + (\delta_X(r_1) + \delta_X(r_2))\]
Linearity is similarly used for $-$ and $sum$. These rules are efficient because they do not depend at all on $X$, only $\delta X$.

\vs The slightly more complicated rules for multiplication, the dot product, and the join operator are a result of their distributivity. We illustrate the derivation of the rule for multiplication below:
\begin{equation*}
\begin{split}
(r_1 + \delta_X(r_1))*(r_2 + \delta_X(r_2)) &= (r_1 + \delta_X(r_1))*r_2 + (r_1 + \delta_X(r_1))*\delta_X(r_2) \\
&= r_1*r_2 + \delta_X(r_1)*r_2 + r_1*\delta_X(r_2) + \delta_X(r_1) * \delta_X(r_2) \\
\implies \delta_X(r_1*r_2) &= \delta_X(r_1)*r_2 + r_1*\delta_X(r_2) + \delta_X(r_1) * \delta_X(r_2)
\end{split}
\end{equation*}
This derivation is also valid for the dot product and join operator as it only uses the distributive property which they all share. While these rules are not quite as efficient as the rules for the linear operators, they are still much more efficient than re-computing. This is because the terms that do depend on an input collection, e.g. $\delta_X(r_1) * r_2$, will constitute a join in practice between an update and only one of the input collections. Since the updates are in general small compared to the size of the input collections, these joins will be much more efficient that the cost of the original join between the two input collections.

\vs Unfortunately, we can see that the expressions for $sng$ and $group$ are not efficient - they do require recomputation. In the case of $sng$, this is because if the key-typed argument is affected by the update, the singleton collection must be fully reconstructed. However, if it is unaffected by the update, so that $e^{new} = e^{old} = e$, the delta expression simplifies as follows:
\begin{equation*}
\begin{split}
sng(e^{new},r) + sng(e^{new},\delta_X(r)) - sng(e^{old},r) &= sng(e,r) + sng(e,\delta_X(r)) - sng(e,r) \\
&= sng(e,\delta_X(r))
\end{split}
\end{equation*}
In practice, usage of $sng$ will largely be confined to the for/yield construction where the yielded key is a variable expression, and so will be unaffected by updates to input collections. 

For $group$, the delta expression is not efficient because the construction of key-nested collections is fundamentally not distributive or linear. Thus, the only way to compute an updated output is to compute the updated input, apply $group$ to this, and substract the previous output. However, we will see in the next section how shredding removes the need for this recomputation by converting the construction of a key-nested collection into the construction of value-nested collection, which does indeed distribute over addition.
	
}

\section{The shredding transformation} {

In this section we define the shredding transformation. As previously described, when we shred a query, we produce both a flat version of the query, in which all key-nested collections have been replaced by labels, and the shredding context, a structure containing the dictionaries defining the labels appearing in the flat query. Therefore shredding consists of two separate transformations - the flattening of the query, which we will denote $(\cdot)^F$, and the derivation of the shredding context, which we will denote $(\cdot)^\Gamma$.

\subsection{Output type of the shredding transformation} {

It will be useful to first examine how shredding works at the type level. Figure \ref{shreddingtypes} defines the two output types of the two constituent transformations.

\begin{figure}
\begin{equation*}
\begin{aligned}[c]
&(\K_1 \times \K_2)^F : \K_1^F \times \K_2^F \\
&(\R_1 \times \R_2)^F : \R_1^F \times \R_2^F \\
&\prim{Int}^F : \prim{Int} \\
\\
&(\K_1 \times \K_2)^\Gamma : \K_1^\Gamma \times \K_2^\Gamma \\
&(\R_1 \times \R_2)^\Gamma : \R_1^\Gamma \times \R_2^\Gamma \\
&\prim{Int}^F : \prim{Unit} \\
\end{aligned}
\qquad
\begin{aligned}[c]
&(\coll{\K}{\R})^F : \coll{\K^F}{\R^F} \\
&[\R]^F: \prim{Label} \\
&\prim{Dom}^F : \prim{Dom} \\
\\
&(\coll{\K}{\R})^\Gamma : \K^\Gamma \times \R^\Gamma \\
&[R]^\Gamma : (\coll{\prim{Label}}{\R^F}) \times \R^\Gamma \\
&\prim{Dom}^\Gamma : \prim{Unit} \\
\end{aligned}
\end{equation*}
\caption{Output types of the shredding transformations.}
\label{shreddingtypes}
\end{figure}

The type returned by $(\cdot)^F$ is straightforward - it is recursively defined to simply replace all boxed ring types with the $Label$ type, and it does nothing to primitive types.

The type returned by of $(\cdot)^\Gamma$ slightly more complicated. The base cases of our primitive types contain no key-nested collections and so their context is empty, which is represented by the $\prim{Unit}$ type. Product types have a context consisting of the contexts of their elements, in a matching structure. Collections also have tupled shredding contexts, the first element for the context of its key and the second for its value.

The interesting case is the boxed ring type $[\R]$. Here the shredding context will consist of two parts - first the dictionary defining the flattened boxed value, and second it recursively contains this value's shredding context. This represents the fact that shredding proceeds recursively - for a boxed collection $\coll{\K}{\R}$ either the key or the value may contain further key-nested collections and so it is shredded to produce the collection $\coll{\K^F}{\R^F}$ before producing the dictionary defining the inner labels. Otherwise, we would only be able to obtain the benefits of shredding for inner collections nested only at one level and not at arbitrary depth.

An important thing to note about these definitions is that the structure of the shredding context is fully defined by the type of the shredded query, and additionally mirrors the output type of the shredded query. This has two important benefits: Firstly, as we will show when defining the transformations themselves on our calculus constructs, this allows contexts to be combined when performing operations on shredded queries. For example, if we add two shredded queries, we need to element-wise perform union on their contexts. Secondly, it means that it is unambiguous as to which dictionary corresponds to which labels in the flat output.

To illustrate the process by which we apply the above rules to determine the flat output type and shredding context structure, we show an example of their application for a collection of type $\Bag{[\Bag{\prim{String}}]} = \coll{[\coll{\prim{String}}{\prim{Int}}]}{\prim{Int}}$:
\begin{flalign*}
(\coll{[\coll{\prim{String}}{\prim{Int}}]}{\prim{Int}})^F&= \coll{\Label}{\Int^F}\\
&= \coll{\Label}{\Int}\\
\end{flalign*}
\begin{equation*}
\begin{split}
(\coll{[\coll{\prim{String}}{\prim{Int}}]}{\prim{Int}})^\Gamma&= ([\coll{\String}{\Int}]^\Gamma \times \Int^\Gamma) \\
&= (((\coll{\Label}{(\coll{\String}{\Int})) } \times (\coll{\String}{\Int})^\Gamma) \times \Unit) \\
&= (((\coll{\Label}{(\coll{\String}{\Int})) } \times (\String^\Gamma \times \Int^\Gamma) \times \Unit) \\
&= (((\coll{\Label}{(\coll{\String}{\Int})) } \times (\Unit \times \Unit) \times \Unit) \\
\end{split}
\end{equation*}

While in this simple example, the nested structure containing various empty contexts and only a single dictionary may seem unnecessary, in complex queries with many levels of nesting, there will be multiple dictionaries within the context and their location is determined by the inner collection they define, and so this type of structure is very useful.

}

\subsection{Formal definition of shredding}

\begin{figure}
\begin{equation*}
\begin{aligned}
&\pair{r_1}{r_2}^F = \pair{r_1^F}{r_2^F} \qquad (\proj{r}{i})^F = \proj{r^F}{i} \\
&(r_1 + r_2)^F = r_1^F + r_2^F \qquad (-r)^F = -(r^F) \\
&(r_1*r_2)^F = r_1^F * r_2^F \qquad (r_1 \cdot r_2)^F = r_1^F \cdot r_2^F  \\
&join(r_1,r_2)^F = join(r_1^F,r_2^F) \qquad sum(r)^F = sum(r^F) \\
&\{x => r\}^F = \{x => r^F \} \qquad sng(k,r)^F = sng(k^F,r^F) \\
&group(r)^F = flatGroup(r^F) \\
\end{aligned}
\qquad
\end{equation*}
\caption{Definition of $(\cdot)^F$ transformation.}
\label{flatdef}
\end{figure}

The flattening transformation $(\cdot)^F$ is formally defined in Figure \ref{flatdef}. It is a simple recursive definition except for the case of $group$, which constructs key-nested collections. For $group(r)$, supposing $r: \coll{(\K_1 \times \K_2)}{\R}$, then $group(r): \coll{(\K_1 \times [\coll{\K_2}{\R}])}{\R}$. We use the notation $flatGroup(r)$ for the expression of type $\coll{K_1^F\times \Label}{\R^F}$ where the key-nested collections have been replaced by labels.

\begin{figure}
\begin{equation*}
\begin{aligned}
&\pair{r_1}{r_2}^\Gamma = \pair{r_1^\Gamma}{r_2^\G} \qquad (\proj{r}{i})^\G = \proj{r^\G}{i}  \qquad (p(x))^\Gamma = \emptyset \\
&(r_1 + r_2)^\G = r_1^\G \cup r_2^\G \qquad (-r)^\G = (r^\G) \\
&(r_1*r_2)^\G = r_1^\G \odot r_2^\G \qquad (r_1 \cdot r_2)^\G = \pair{r_1^{\G_1} \cap r_2^{\G_1}}{r_1^{\G_2} \odot r_2^{\G_2}}  \\
&join(r_1,r_2)^\G = \pair{\pair{r_1^{\G_{1_1}} \cap r_2^{\G_{1_1}}}{r_1^{\Gamma_{1_2}},r_2^{\Gamma_{2_2}}}}{r_1^{\G_2} \odot r_2^{\G_2}} \\&sum(r)^\G = r^\G_2 \qquad sng(k,r)^\G = sng(k^\G,r^\G) \\
&group(r)^\G = \pair{dict(r^F)}{r^\G} \\
\end{aligned}
\qquad
\end{equation*}
\caption{Definition of $(\cdot)^\Gamma $ transformation.}
\label{contextdef}
\end{figure}

The definition of $(\cdot)^\G$, given in Figure \ref{contextdef}, is much more involved. In these formulae, we assume the context of collection-typed arguments has two elements $\G_1$ and $\G_2$, as we know from our definition of the types of shredding contexts that the context of a collection $\coll{\K}{\R}$ is of the form $\pair{\K^\G}{\R^\G}$.

The derivations for pairs, $sng$ and infinite mappings are straightforward - we construct the shredding context by simply pairing the contexts of the constituent parts. Sum is also straightforward - since summing a collection removes the keys, we only need the context for the values, so return the second part of the input context only.

For the other operators, it is more complicated, as they require combining the corresponding dictionaries. For example, when adding two shredded collections, the two dictionaries for each boxed ring type must be added together to produce a dictionary containing the definitions for the key-nested collections from both collections. This is represented with the union operator.

For the dot product, we represent the derivation of the shredding context with the operation $\odot$, defined as:
\begin{equation*}
\begin{split}
&r_1: \coll{\K_1}{\R_1}\textrm{, }r_2: \coll{\K_2}{\R_2} \\
&r_1^\G \odot r_2^\G = \pair{\pair{r_1^{\G_1}}{r_2^{\G_1}}}{r_1^{\G_2} \odot r_2^{\G_2}}
\end{split}
\end{equation*}

This operation, according to the definition of the dot product, pairs the contexts of the keys of the operands and is recursively applied to the values.

For multiplication, the key's context is the intersection of the two operands key contexts, since keys will only appear in the output if they appear in both inputs. The value's context, according to the definition of multiplication, is derived again using the $\odot$ operation as the value of the result is the dot product of the values.

For $join$, the first element of the key is similarly the intersection of contexts, and the second element of the key pairs the context of the second elements of the inputs. Again, as the value is computed as the dot product of the input values, we use the $\odot$ operation to compute the context of the vaue.

Finally, the context for $group(r)$ is denoted $\pair{dict(r^F)}{r^\G}$. This represents the fact that $r$ is recursively shredded, and then the context $r^\G$ is paired with the dictionary defining newly replaced key-nested collections at the top level of $r^F$. When looking up the definition of the inner collections constructed by $group(r)$, first the dictionary $dict(r^F)$ would be used, and if $r$ itself contained further nested collections, the definitions of these would be contained within the context $r^\G$.

We can see now that when shredded, the expression $group(r)$ no longer constructs a key-nested collection. Instead, with $r: \coll{(\K_1 \times \K_2)}{\R}$, it constructs a value-nested collection in the form of $dict(r^F)$ which will be a collection of type $\coll{\Label}{\coll{\K_2}{\R}}$. We will see in Chapters \ref{evaluation} and \ref{incrementalisation} how the implementation of $flatGroup$ and $dict$ enable load-balancing and efficient incrementalisation.

\subsection{Example application}

Recall the example query, which we expressed as an NRC query in \ref{examplequery}. The output is of type $\prim{Output}: \coll{(\prim{Artist} \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}])}{\prim{Bool}}$. This represents a collection where each artist is paired with a nested collection of their tracks, where each track is itself paired with a further nested collection of its aggregate ratings by date. While it will be too involved too derive the entire shredded expression here, we will derive the type of the flat output and shredding context, and explain what these mean to give an idea of how shredding works in practice. In the following, we will index the $\Label$ types and omit unit shredding contexts for clarity. Where we have omitted such contexts, we will indicate this by using $\approx$.

First we derive the type of the flat output:
\begin{equation*}
\begin{split}
\prim{Output}^F &=(\coll{(\prim{Artist} \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}])}{\prim{Bool}})^F \\
&= \coll{(\prim{Artist} \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}])^F}{\prim{Bool}}^F \\
&= \coll{(\prim{Artist}^F \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}]^F)}{\prim{Bool}} \\
&= \coll{(\prim{Artist} \times Label_1)}{\prim{Bool}} \\
\end{split}
\end{equation*}

The only change is that the outermost nested collections has been replaced by labels, thus giving us a flat output. Note that there is no indication in the flat output that there is a second set of labels defining the further inner collection. We will now derive the type of the shredding context:
\begin{equation*}
\begin{split}
Output^\G &=(\coll{(\prim{Artist} \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}])}{\prim{Bool}})^\G \\
&=(\prim{Artist} \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}])^\G \times \prim{Unit} \\
&\approx\prim{Unit} \times [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}]^\G \\
&\approx [\coll{(\prim{Track} \times [\Bag{\prim{Date}]})}{\prim{Bool}}]^\G \\
&=(\coll{\Label_1}{\coll{((\prim{Track} \times [\Bag{\prim{Date}}])}{\prim{Bool}})^F}) \times ((\coll{\prim{Track} \times [\Bag{\prim{Date}}])}{\prim{Bool}})^\G \\
\end{split}
\end{equation*}
where:
\begin{equation*}
\begin{split}
\coll{((\prim{Track} \times [\Bag{\prim{Date}}])}{\prim{Bool}})^F &=\coll{(\prim{Track}^F \times [\Bag{\prim{Date}}]^F)}{\prim{Bool}}^F \\
&=\coll{(\prim{Track} \times \Label_2)}{\prim{Bool}} \\
\end{split}
\end{equation*}
and:
\begin{equation*}
\begin{split}
((\coll{\prim{Track} \times [\Bag{\prim{Date}}])}{\prim{Bool}})^\G &= (\prim{Track} \times [\Bag{\prim{Date}}])^\G \times Unit\\
&\approx \prim{Unit} \times [\Bag{\prim{Date}}]^\G \\
&\approx (\coll{\Label_2}{\Bag{\prim{Date}}^F}) \times \Bag{\prim{Date}}^\G \\
&= (\coll{\Label_2}{\Bag{\prim{Date}}}) \times (\prim{Unit} \times \prim{Unit}) \\
&\approx \coll{\Label_2}{\Bag{\prim{Date}}}
\end{split}
\end{equation*}
Hence we have:
\begin{equation*}
\begin{split}
&\prim{Output}^F = \coll{(\prim{Artist} \times Label_1)}{\prim{Bool}} \\
&\prim{Output}^\G \approx (\coll{Label_1}{\coll{((\prim{Track} \times \Label_2)}{\prim{Bool}}))} \times (\coll{\Label_2}{\Bag{\prim{Date}}}) \\
\end{split}
\end{equation*}
Thus, the inner collection of track ratings by date for each artist is replaced with an identifying label (represented by $\Label_1$) in the flat output. This label is defined in the first dictionary in the context, which has values of type $\coll{(\prim{Track} \times \Label_2)}{\prim{Bool}}$. This underlines the recursive nature of shredding - since the outermost nested collection has another collection nested within it, (which is the ratings for a particular track by date), the definitions of its labels themselves contain labels (represented by $\Label_2$). The definition of these labels are given by the second dictionary in the context, which is of type $\coll{\Label_2}{\Bag{\prim{Date}}}$.

Hence, the output of a shredded query, no matter how deeply it is originally nested, is translated into a flat query, and set of queries (the dictionaries) which construct only a single value-nested collection. Thus, using this automatic and compositional transformation, we have reduced the task of load-balancing and efficiently updating arbitrarily nested queries into doing so only for these simplified nested queries. We will see in Chapter \ref{evaluation} how we can load-balance and efficiently update such queries using a technique called sharding.










}