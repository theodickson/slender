\chapter{Nested Relational Calculus}

In this chapter we explain the variant of the Nested Relational Calculus used in this work.
First we explain how its semantics allow arbitrary nesting of collections, and introduce the core algebraic operators, showing how they enable a wide range of queries. Then we introduce some syntactic constructions which allow us to more naturally express nested queries. We explain the two forms that nested queries can take (key nesting and value nesting), and why the former is preferable semantically but not efficiently parallelised or incrementalised. Next we introduce the delta expressions for each operator, and show that while most operators incrementalise efficiently due to their algebraic properties, others must be recomputed with each update. Finally we provide a full description of the shredding transformation, and show how it allows us to simulate the semantics of a single key-nested query with a sequence of value-nested queries, thus retaining the performance benefits of value-nesting.


\section{Type system} {

In order to apply the shredding operation outlined in the previous chapter, we introduce a variant of the Nested Relational Calculus (NRC) which uses \textit{generalised multiset semantics}. As opposed to a regular multiset, or \textit{bag}, in which each element in a set is associated with an integer value, in our generalised multiset semantics we model collections by mappings $ \coll{\K}{\R} $ where values can be of any type which admits a ring structure $ (\R,0_\R,+_\R,-_\R,1_\R,*_\R) $. In the following we will show the two key properties of these semantics. Firstly, that they admit nesting of collections to arbitrary depth, and secondly, that they give rise to the potential for efficient incrementalisation and parallelisation since the majority of the operators we will introduce are distributive ring operations.

Figure \ref{nrctypes} formally describes the type system that enables these semantics, using an inductive definition.

\begin{figure}
\begin{equation*}
\begin{aligned}
\R := \prim{Int} \OR \R \times  \R \OR \coll{\K}{\R} \\
\K := \prim{Dom} \OR  [\R]  \OR \prim{Label} \\
\end{aligned}
\qquad
\begin{aligned}
\end{aligned}
\end{equation*}
\caption{The type system of the NRC}
\label{nrctypes}
\end{figure}

It will also be useful to introduce the notation $\Bag{\K} := \coll{\K}{\prim{Int}}$, for collections with integer multiplicity.

\subsection{Ring types} {
The base case of our ring type is the integers, which of course admits the ring structure $(\mathbb{Z},0,+,-,1,*)$. Note that it is trivial to extend this calculus to other primitive types admitting a ring structure, such as the real numbers, but for brevity we omit these. We also note that with just integers, we can easily model booleans by representing false as 0 and true as any positive integer, since then integer multiplication models the boolean AND and integer addition models boolean OR. This will be useful later when developing a construct which can filter collections.

The first of our inductive cases is the product type $\R \times \R$. A product of two ring types $\R_1$ and $\R_2$ trivially admits a ring structure by pairing the 0 and 1 elements and applying the operations of $\R_1$ and $\R_2$ element-wise. Although in practice we will be able to use tuples of any arity, in this formalism we only define operations for a pair, as higher arities are isomorphic to nesting products within the second element.

The second and crucial inductive case is the collection type $\coll{\K}{\R}$, which itself admits a ring structure in which $\R$'s operations are applied element-wise over the key space $\K$. For example, if we have two collections $X: \coll{\K}{\R}$ and $Y: \coll{\K}{\R}$ then:

\begin{equation*}
\begin{split}
& (X+Y)(k)  = X(k) +_\R Y(k) \\
& (X*Y)(k) = X(k) \times_\R Y(k)
\end{split}
\end{equation*}

If $\R$ is an $\prim{Int}$, so that $X,Y: \Bag{\K}$, then we can see that $+$ corresponds to bag union. We can also see that $\times$ is join-like - a key will only have non-zero value in the resulting collection if it has non-zero value in each of $X$ and $Y$.

In this way, we can use collections themselves as multiplicities. For example, a collection of type $\coll{\K_1}{(\coll{\K_2}{\R})}$ associates a collection of type $\coll{\K_2}{\R}$ to each key of type ${\K_1}$. This is what we call \textit{value} or \textit{ring} nesting and is the first way to obtain nested collections.

\subsection{Key types} {

For keys, the base types are the $\prim{Dom}$ types. These are the types of the active domain of the database. When using Apache Spark for example, this constitutes all serializable Scala data types \cite{}. In a typical relational database this would be much more restricted, to types such as INT, FLOAT, VARCHAR, TIMESTAMP, and so on. 

The type $[\R]$ (the \textit{boxed ring} type) offers ring types for use as keys while retaining the view of their ring structure, thus marking the places where shredding can be performed. For example, a collection of type $\coll{(\K_1,[\coll{\K_2}{\R}])}{\prim{Int}}$ maps a pair of two key types, $\K_1$ and the boxed ring type, $[\coll{\K_2}{\R}]$ to a multiplicity of $\prim{Int}$ type. This is what we call \textit{key nesting}. 

The $\prim{Label}$ type represents places we have applied shredding, in order to replace key-nested collections with labels. For example, in a query which produces a result of type  $\coll{(\K_1,[\coll{\K_2}{\R}])}{\prim{Int}}$, we would expect shredding to instead produce a result of type 
$\coll{(\K_1,\prim{Label})}{\prim{Int}}$, along with a dictionary of type $\coll{\prim{Label}}{(\coll{\K_2}{\R})}$. Note that both of these types do not contain key-nested collections. Instead our dictionary uses value-nesting. This will be crucial to how we efficiently incrementalise such shredded queries.

}

\section{Expressions}

\begin{figure}
\begin{equation*}
\begin{split}
k := \ & c \OR x \OR \langle k_1, k_2 \rangle \OR \proj{k}{i} \\ \\
r := \ & c \OR X \OR \langle r_1, r_2 \rangle \OR \proj{r}{i} \OR \\
& r_1 + r_2 \OR -r \OR r_1 \ast r_2 \OR r_1 \cdot r_2 \OR \\
& join(r_1,r_2) \OR sum(r) \OR p(k) \OR \\
& sng(k,r) \OR \{ x => r \} \OR group(r)
\end{split}
\end{equation*}
\caption{Valid expressions in the NRC.}
\label{nrcexprs}
\end{figure}

Figure \ref{nrcexprs} introduces the constructions that define valid expressions in our calculus. In this section we explain these and discuss their algebraic properties.

\subsection{Ring expressions} {
The base expressions of ring type are constants and input collections, denoted by $c$ and $X$ respectively. Constants will be of $\prim{Int}$ type in this restricted formalism, but in practice can be of any numeric type or other primitive type admitting a ring structure. Input collections are datasets of type $\coll{\K}{\R}$, where $\K$ is any valid key type and $\R$ any valid ring type. For example, in our motivating example, the input collection \textit{ratings} is of type $\coll{Artist \times Track}{\prim{Int}}$. We also have a standard tupling operator denoted by $\langle , \rangle$ and can project such product types using the notation $\proj{r}{i}$.

Next we have $+$, $-$, and $\ast$, the algebraic operators defined by the ring structure of $\R$. It will be important when discussing incrementalisation and parallelisation to note that  $\ast$ is distributive with respect to $+$:
\[
a*(b + c) = a*b + a*c.
\]

The dot product is a generalised multiplication operator which accepts any two arguments of ring type. It is defined recursively as:
\begin{equation*}
\begin{split}
& \textrm{If } X: \prim{Int}, \ Y: \prim{Int}\textrm{, then } X \cdot Y = X * Y \\ \\
& \textrm{If } X: \coll{\K}{\R}, \ Y: \prim{Int}\textrm{, then } X \cdot Y : \coll{\K}{\R \cdot \prim{Int}}, \\
& (X \cdot Y)(k) = X(k) \cdot Y\textrm{, for all }k: \K \\ \\
& \textrm{If } X: \coll{\K_1}{\R_1}, \ Y: \coll{\K_2}{\R_2}\textrm{, then } X \cdot Y : \coll{\langle \K_1, \K_2 \rangle}{\R_1 \cdot \R_2} \\
& (X \cdot Y)(\langle k_1, k_2 \rangle) = X(k_1) \cdot Y(k_2)\textrm{, for all }k_1,k_2: \K
\end{split}
\end{equation*}

This operation can natively implement certain useful operations. For example, the dot product of $\Bag{\K_1}$ and $\Bag{\K_2}$ produces their cartesian product.

The dot product is distributive:

\begin{equation*}
\textrm{\textit{(Proof of dot product distributivity)}}
\end{equation*}

It also allows us to extend the native ring multiplication operation to collections of the same key type but differing ring types, as follows:

\begin{equation*}
\begin{split}
& X: \coll{\K}{\R_1}, \ Y: \coll{\K}{\R_2} \\
& X * Y : \coll{\K}{\R_1 \cdot \R_2} \\
& (X*Y)(k) = X(k) \cdot Y(k)
\end{split}
\end{equation*}

We will see how this extension to multiplication allows us to define a for-comprehension construct with very natural semantics.

Although the $*$ operator can be described as join-like when used on collections, it performs this join on the entire key, and so is not general enough to model many typical joins. Thus we introduce a separate join operator, which only operates on collections, and joins only on the first element of a product-typed key. It is defined as follows:

\begin{equation*}
\begin{split}
& X: \coll{(\K,\K_1)}{\R_1},  Y: \coll{(\K,\K_2)}{\R_2} \\
& join(X, Y): \coll{(\K, (\K_1,\K_2))}{\R_1 \cdot \R_2} \\
& join(X, Y)(\langle k, \langle k_1, k_2 \rangle \rangle) = X(\langle k, k_1 \rangle) \cdot Y(\langle k, k_2 \rangle)
\end{split}
\end{equation*}

We can see that this is a join as a key $\langle k, \langle k_1, k_2 \rangle \rangle$ will only be non-zero in the output if $\langle k, k_1 \rangle$ is non-zero in $X$ and $\langle k, k_1 \rangle$ is non-zero in $Y$. It is general enough to model all inner-joins if we re-order the elements (or columns) of the key such that the element(s) we wish to join on constitute the first element of the key and the other columns are nested within the second element. 

The $join$ operator is also distributive:

\begin{equation*}
\textrm{\textit{(Proof of join distributivity)}}
\end{equation*}

The sum operator is another which is used in our for-comprehension construct, and is defined as follows: 
\begin{equation*}
\begin{split}
 & X: \coll{\K}{\R} \\
 & sum(X): \R \\
 & sum(X) = \sum_{k: K} X(k)
\end{split}
\end{equation*}
 
It is only defined for collection types, and, for example, when applied to a bag returns its aggregate count.
 
The predicate operator $p(k)$ encapsulates any function accepting a key and returning an integer in the set $\{0,1\}$, thus modelling a boolean output. We will see how it enables us to do things such as filter collections.
 
The \textit{singleton} constructor is $sng$. With $k: \K$ and $r: \R$, $sng(k,r)$ constructs a collection of type $\coll{\K}{\R}$ with the single element $k  \mapsto r$. We will see how this combines with our for-comprehension construct to create nested collections.
 
The infinite mapping $\{x => r\}$ allows us to express functions from key types to value types as collections of infinite domain, where the key is a variable expression $x$ and the value is a ring expression $r$ which may use the variables introduced in $x$. When such an expression is multiplied with a finite collection, the variable expression is bound to each of the keys in the finite collection in order to produce a concrete result.

The following example shows us how this allows transformations of finite collections:

Let $k_1,k_2: K$ be variables. Let $X: \Bag{\K \times \K}$, $p(\langle k_1, k_2 \rangle) = k_1 == k_2$. \\
Let $Y = X * \{\langle k_1, k_2 \rangle => p(\langle k_1, k_2 \rangle)\}$. Applying the definition of *, and assuming $k_1,k_2$ are in the domain of $X$: \\
\begin{equation*}
\begin{split}
Y(\langle k_1, k_2 \rangle) &= X(\pair{k_1}{k_2}) \cdot 1 = X(\pair{k_1}{k_2})\textrm{, if } k_1 == k_2 \\
&= X(\pair{k_1}{k_2}) \cdot 0 = 0\textrm{, otherwise}
\end{split}
\end{equation*}

Hence $Y$ is X filtered to only those keys whose first and second elements are equal.

Outside of the domain of the finite collection, the value of the infinite mapping is not relevant since even if we calculated it, it would be multiplied with zero. Hence it it useful to think of multiplication in this context as binding the variable expression in the infinite mapping to each key in the domain of the finite mapping and in order to produce a new value with is combined using dot product with the original value in the finite mapping.

The last ring-typed construct is group, and is the operator which constructs key-nested collections. It is defined on collections with keys of pair type, as follows:

\begin{equation*}
\begin{split}
&X: \coll{\K_1 \times \K_2}{\R} \\
&group(X): \coll{\K_1 \times [\coll{\K_2}{\R}]}{\prim{Bool}} \\
&group(X)(\pair{k_1}{k_2'}) = true \iff k_2' = \sum_{\pair{k_1'}{k_2} \mapsto r : k_1' = k_1} {k_2 \mapsto r} 
\end{split}
\end{equation*}

This groups $X$ by the first element of its key and creates a key-nested collection mapping the second elements of the key to their values. For example:

\begin{equation*}
\begin{split}
&X: \Bag{\prim{String}\times \prim{String}} \\
&X = \{(a,b) \mapsto 1, (a, c) \mapsto 2, (b,d) \mapsto 3\} \\
&group(X) = \{\langle a, \{b \mapsto 1, c \mapsto 2\} \rangle \mapsto true, \langle b, \{d \mapsto 3 \} \rangle \mapsto true \}
\end{split}
\end{equation*}

\textit{(explanation of why key-nesting makes sense here, may want to focus on semantics of further joins etc instead of keeping track of multiplicity)}

We recognise that this being the only way to construct key-nested collections is quite restrictive. In fact, in earlier work \cite{draftpaper}, the variant of the NRC used did not include this construct, but instead used a more general construct $toK$, which would box arbitrary sub-queries of ring type. Unfortunately, although this allowed for a more general query language, the queries written in this way proved highly impractical to implement within Spark. Appendix \cite{groupvstok} contains a discussion on this for the interested reader. Despite this, we will see in section \cite{} that even with this restriction we are still able to express a wide range of quite complex queries.

}

\subsection{Key expressions} {

The base key expressions are either constants, denoted $c$, or variables, denoted $x$, which are strictly those introduced as the keys of an infinite mapping.

As with ring expressions, we also have tupling and projection. 
}




}