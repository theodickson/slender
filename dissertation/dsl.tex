\chapter{Implementation of the DSL}

In this chapter we describe how a DSL was created in Scala which can express any query in our version of the Nested Relational Calculus, where the relations may be either local Scala collections or Spark RDDs.

We first explain why Scala was chosen as our language, with particular attention to the features which make it well-suited to the implementation of DSLs.

Then we show how and why the basic Abstract Syntax Trees (ASTs) were implemented using Scala's polymorphic case classes and Shapeless HLists.

Finally we describe the techniques used to allow these ASTs to be generated with syntax which closely matches that of the NRC.

\section{Representing abstract syntax trees}

As our calculus consists purely in constants, variables, unary operators and binary operators, it is straightforward to represent any expression as an abstract syntax tree (AST), where the leaves are either constants or variables and the other nodes are operators. For example, below we see how a simple usage of the for/yield construct translates into an AST:

\begin{equation*}
\begin{split}
\For{x}{X} \Collect{x + 1} &= sum(X*\{x => x + 1\}) \\
&\cong Sum(Multiply(X,InfMapping(x,Add(x,1))))
\end{split}
\end{equation*}

The core task is thus in creating a representation of these ASTs. Scala provides us with a feature which is perfectly suited to this, in the form of a \textit{case class} \cite{caseclass}. (In fact, Scala ASTs themselves are represented by the compiler with case classes\cite{compilerasts}). A case class is type of class in Scala specialised for immutable objects fully defined by their construction arguments. By default, they are compared for equality and calculate their hash value from these arguments, and not from their reference. They also enable the use of \textit{pattern-matching} \cite{patternmatch}, a powerful syntactic construction in Scala which will make manipulating these ASTs far easier.

\begin{figure}
\begin{lstlisting}
case class LiteralExpr[V](value: V) extends ExprNode

case class AddExpr[E1,E2](c1: E1, c2: E2) extends ExprNode

case class NegateExpr[E](c1: E) extends ExprNode

case class GroupExpr[E](c1: E) extends ExprNode

case class InfiniteMappingExpr[K,R](key: K, value: R) extends ExprNode

case class SngExpr[K,R](key: K, value: R) extends ExprNode

case class Variable(name: String) extends ExprNode

\end{lstlisting}
\caption{Signatures of expression nodes.}
\label{exprnodes}
\end{figure}

In figure \ref{exprnodes} we present the signatures of the case classes for many of the constructs in our formalism. We omit several of the algebraic operators, as these are exactly analogous to those shown. Note that they all inherit from a common trait \lstinline{ExprNode}, and that they are polymorphic in their construction arguments, so that the compile-time type of an AST node contains the types of all of its child nodes. For example, the node:

\begin{lstlisting}

AddExpr(MultiplyExpr(1,2),3)
\end{lstlisting} 

will have type \lstinline{AddExpr[MultiplyExpr[LiteralExpr[Int],LiteralExpr[Int]],LiteralExpr[Int]]}.
This will be crucial later on for implementing the evaluation of these ASTs.

The other omission from the case classes shown is product types. Instead of creating explicit case classes for product types, such as:

\begin{lstlisting}

case class ExprPair[E1,E2](e1: E1, e2: E2) extends ExprNode
\end{lstlisting} \vspace{1em}

we will design the rest of our framework to treat products of these case classes directly as expressions, without any common inheritance, using a design pattern called a \textit{typeclass}, which will be explained later.

Additionally, we will not use native Scala tuples to represent these products. This is because Scala tuples have a different type for each arity, with no common ancestor except for the trait \lstinline{Product}, which among other things does not support element access. This makes it impossible to write code which applies common logic to tuples of different arities, something we will have to do in many places when writing the code for evaluation. Instead, in each of these situations we would have to write separate implementations of a class or function for every arity of tuple we wish to support.
	
Instead, we will use Shapeless \cite{shapeless}, a generic programming library for Scala. The key feature of shapeless is the \lstinline{HList} (or \textit{heterogenous list}), which can be thought of as a linked list in which the type of each element may be different but is known at compile time. This is actually quite straightforwardly implemented, using the following interface (presentation is simplified):

\begin{lstlisting}

trait HList
case class HCons[H,T <: HList](h: H, t: T) extends HList
case object HNil extends HList
\end{lstlisting} \vspace{1em}

Here, \lstinline{HCons} and \lstinline{HNil} act as \lstinline{Cons} and \lstinline{Nil} do in a standard Scala immutable linked list \cite{scalalist}. But, since \lstinline{HCons} is polymorphic in both the type of its head and its tail, an \lstinline{HList} is therefore polymorphic in all of its elements.

It can be noted then that in terms of the expressiveness of types, this offers nothing beyond limiting ourselves to only using \lstinline{Tuple2}, and representing higher arities by nesting these tuples. For example, an \lstinline{HCons[T1,HCons[T2,HCons[T3,HNil]]]} is isomorphic to a \lstinline{Tuple2[T1,Tuple2[T2,Tuple2[T3,Unit]]]]}.

However, the Shapeless library additionally offers many list-like methods for manipulating \lstinline{HList}s, such as concatenation and element access by index, which will be helpful to us later on. It also offers the same syntax for constructing \lstinline{HList}s as can be used to construct regular Scala lists, the double colon (\lstinline{::}). For example, we can construct an \lstinline{HList} isomorphic to the tuple:
\begin{lstlisting}
(LiteralExpr(1),LiteralExpr(2),LiteralExpr(3))
\end{lstlisting}

using the syntax
\begin{lstlisting}
LiteralExpr(1)::LiteralExpr(2)::LiteralExpr(3)::HNil.
\end{lstlisting}

If we were using nesting of Tuple2 values, we would have to write the triple as

\begin{lstlisting}
(LiteralExpr(1),(LiteralExpr(2),(LiteralExpr(3),()))).
\end{lstlisting}

Now we can represent any expression as an AST. However, it is cumbersome to generate this by directly constructing every node in the tree. For example, to generate the AST for the expression: 

\begin{equation*}
\For{x}{X} \Yield{(\For{y}{x} \Collect{y+1})}
\end{equation*}

We would need to write the following code:

\begin{lstlisting}

val inner = SumExpr(
  MultiplyExpr(
    Variable('x'),
    InfMapping(Variable('y'),AddExpr(Variable('y'),LiteralExpr(1))
  )
)
val expr = SumExpr(
  MultiplyExpr(
    X,InfMapping(Variable('x'),SngExpr(Variable('x'),inner))
  )
)
\end{lstlisting} \vspace{1em}

In the next section we describe how we implemented syntax almost identical to the formalism to generate this same AST.

\section{Implementing natural syntax}

In order to generate queries with more natural syntax, the first task is to implement prefix syntax for the unary operators and infix syntax for the binary operators. For example, we would like to be able to write:
\vs
\begin{lstlisting}
 -LiteralExpr(1) * LiteralExpr(2)
\end{lstlisting}
\vs
in order to construct the AST:
\vs
\begin{lstlisting}
MultiplyExpr(NegateExpr(LiteralExpr(1)),LiteralExpr(2))
\end{lstlisting}
\vs

Scala provides the perfect features for this. In the case of prefix syntax, this can be achieved for various symbols, including $-$, by implementing the method \lstinline{unary_-}. The compiler simply parses the expression \lstinline{-LiteralExpr(1)} as \lstinline{LiteralExpr(1).unary_-}. In the case of infix syntax, this can be achieved as a natural result of the fact that Scala does not require the use of dots or brackets to invoke methods.  \lstinline{LiteralExpr(1) * LiteralExpr(2)} is desugared by the Scala compiler to \lstinline{LiteralExpr(1).*(LiteralExpr(2))}.

Hence it remains to implement the method \lstinline{*}. Unfortunately, this is not straightforward. These methods must be available to all ring-typed expressions. However, there is no common ancestor class for all ring-typed expressions - although our explicit case classes all inherit from \lstinline{ExprNode}, products are represented as \lstinline{HList}s which clearly do not. Therefore there is no single place to implement these methods.

\subsection{The \lstinline{Expr} typeclass}

In Scala, by using design pattern borrowed from Haskell called a \textit{typeclass}, and a powerful native feature called an \textit{implicit class}, we can circumvent both issues. The discussion in this section may seem excessive for explaining a syntactic feature, and can be skipped by readers less familiar with Scala, but the ideas introduced are used with greater significance later when implementing evaluation, so it is worth explaining them fully for this simpler use case.

A typeclass in Scala is a polymorphic trait with one type argument. For example, our expression typeclass will have the signature:

\vs \begin{lstlisting}
trait Expr[T]
\end{lstlisting}

The existence of an instance of a typeclass for a type \lin{T} implies that \lin{T} can be used in a particular way, and with its methods it may implement some behaviour for type \lin{T}. This is in contrast to standard object-oriented inheritance, it which \lin{T} would have to extend an \lin{Expr} trait directly. Then, when we wish to write a method operating on \lin{Expr}-compatible objects, we write the signature as follows:

\vs \begin{lstlisting}
def foo[E](e: E)(implicit expr: Expr[E]) =  { ... }
\end{lstlisting} \vs
Similarly, we can use the same pattern for a construction argument of a class:
\vs \begin{lstlisting}
class Foo[E](e: E)(implicit expr: Expr[E]) { ... }
\end{lstlisting} \vs

These signatures will accept an argument of any type \lin{E}, as long as they are also provided with a value of type \lin{Expr[E]} for the parameter \lin{expr}. But, because \lin{expr} is marked with the keyword implicit, the compiler can do this automatically using a process called implicit resolution \cite{implicitresolution}. In essence, this means that if a value of the proper type for a given implicit parameter can be generated by recursively calling a sequence of methods which are also marked as implicit, then it will do so, and hence the parameter needn't be passed explicitly.

For example, for \lin{Expr[T]} we provide an implicit method which generates an instance of \lin{Expr[T]} for any \lin{T} which is one of our explicit AST operator nodes:
\vs \begin{lstlisting}
implicit def ExprNode[E <: ExprNode]: Expr[E] = new Expr[E] {}
\end{lstlisting} \vs
And we also provide implicit methods to recursively generate instances for \lin{HList}s consisting purely of elements which themselves have instances of \lin{Expr}:
\vs\begin{lstlisting}
implicit def HNilExpr: Expr[HNil] = new Expr[HNil] {}

implicit def HConsExpr[H,T <: HList]
  (implicit exprH: Expr[H],
   exprT: Expr[T]): Expr[H::T] = new Expr[H::T] {}
\end{lstlisting}\vs

This is effectively an encoding of the inductive rules which define a valid expression: The base case is that the expression is either an \lin{ExprNode} or an \lin{HNil} (i.e. the empty product). The fact that these are the base cases can be seen by noting that the implicit methods to generate Expr instances for these types do not take any parameters themselves - the compiler can directly invoke them for these types. Then, the inductive case is that the expression is an \lin{HList} consisting of valid \lin{Expr} elements. This can be seen by noting that, for product types, the compiler can only create an \lin{Expr} instance for them if it can recursively create \lin{Expr} instances for both the head type and tail types in order to provide the implicit parameters of the method \lin{HConsExpr}.

Later, we will use this ability to encode inductive rules in a system of implicit methods to great effect when we use it to automatically generate implementations of algebraic operators for types of arbitrary complexity.

Finally, it remains to use this typeclass to implement our operators for all valid objects. We cannot simply implement the operators within the definition of \lin{Expr[T]}, as then they will only be available to instances of \lin{Expr[T]} and not the expressions themselves, e.g. an \lin{AddExpr}.
Instead, we will use an \textit{implicit class} \cite{implicitclass}. An implicit class is like a regular class, except it can only have one explicit construction argument, say of type \lin{T}. The existence of such an implicit class then allows its methods to be used as though they are methods of the type \lin{T}. By additionally requiring an implicit argument of type \lin{Expr[T]}, we will instead allow its methods to used as though they are methods of any type \lin{T} which is a valid \lin{Expr} type.
We present a simplified version of this implicit class, which we call \lin{ExprOps} (for expression operations):
\vs \begin{lstlisting}
implicit class ExprOps[T](e: Expr)(implicit expr: Expr[T]) {
  def unary_- = NegateExpr(e)
  def +[T1](e1: T1)(implicit expr1: Expr[T1]) = AddExpr(e, e1)
...
}
\end{lstlisting} \vs
Now, since the compiler can provide instances of \lin{Expr[T]} for any valid expression, the compiler can additionally convert any valid expression into an instance of \lin{ExprOps}, and thus we can use these operators with prefix and infix syntax for any valid expression.

\subsection{Implementing for-comprehension syntax}

Next we would like to be able to use the for/yield and for/collect comprehensions in order to construct ASTs more naturally. We only provide a brief overview of this implementation as it uses more standard Scala features which are of less theoretical interest.

Although \textit{for} and \textit{yield} are reserved keywords in Scala, we can use their capitalised versions. Therefore, we would like the following expressions to be valid and generate the corresponding ASTs:

\vs \begin{lstlisting}
val forCollect = For (Variable('x') <- X) Collect r
val forCollectAst = SumExpr(
  MultiplyExpr(X,InfiniteMappingExpr(Variable('x'), r))
)

val forYield = For (Variable('x') <-- X) Yield k --> r 
val forYieldAst = SumExpr(
  MultiplyExpr(X,InfiniteMappingExpr(Variable('x'),SngExpr(k,r)))
)
\end{lstlisting} \vs

To understand how such syntax can be implemented within Scala, we will use example of the for/collect comprehension. The above statement \textit{forCollect} is desugared as:
\vs \begin{lstlisting}
For.(Variable('x').<--(X)).Collect(r)
\end{lstlisting}\vs
Therefore, we need to implement:
\begin{itemize}
\item{The \lin{<--} method for variables, which pairs them with an expression \lin{X} representing a finite collection.}
\item{A class  \textit{For}, which is constructed with one of these variable/collection pairs. \textit{For} needs additionally a method \textit{Collect}, which takes a ring-typed expression and constructs the AST:
\vs\begin{lstlisting}
SumExpr(MultiplyExpr(X,InfiniteMappingExpr(v,r)))
\end{lstlisting}\vs
Where X is the collection passed to the instance of \textit{For} at construction, \textit{v} is the variable passed to \textit{For}, and \textit{r} is the ring-typed expression passed to the \textit{Collect} method.
}
\end{itemize}

The full details are included in Appendix \ref{codebase} in the file \textit{Syntax.scala}.

\subsection{Implicit conversion of literal values}

Finally, we would like to be able to use certain literal values, such as integers and booleans, in our DSL without explicitly initialising \lin{LiteralExpr} nodes. We would also be able to use the more natural tuple syntax instead of constructing product types with \lin{HList} syntax. 

This will allow us to write, for example:
\vs\begin{lstlisting}
(1,1) dot (2,2)
\end{lstlisting}\vs
And have this Scala expression generate the AST:
\vs\begin{lstlisting}
DotExpr(LiteralExpr(1)::LiteralExpr(1)::HNil, LiteralExpr(2)::LiteralExpr(2)::HNil).
\end{lstlisting}\vs
As there is, for example, a one-to-one correspondence between integers, and literal expressions contains integers, or between tuples and \lin{HList}s, this is straightforward to implement with Scala?s implicit conversions. The full implementation is again in Appendix \ref{codebase} in the file \textit{Syntax.scala}.

\section{DSL overview}

