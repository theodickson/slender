\chapter{Implementation of the DSL} \label{dsl}

In this chapter we describe how we create a DSL which can express any query in our version of the Nested Relational Calculus, where the relations may be either local Scala collections or Spark RDDs. We use Scala rather than the other languages with Spark APIs due to its many features which are suited to the design of DSLs.

First we show how and why the abstract syntax trees (ASTs) are implemented using Scala's polymorphic case classes and Shapeless HLists.

Then we describe the Scala features which enable these ASTs to be generated with syntax which closely matches that of the NRC.

Finally, we demonstrate its usage by expressing an example query.


\section{Representation of NRC queries}

As our calculus consists purely in constants, variables, unary operators and binary operators, it is straightforward to represent any query as an AST, where the leaves are either constants or variables and the other nodes are operators. For example, below we see how a simple usage of the for/yield construct translates into an AST:

\begin{equation*}
\begin{split}
\For{x}{X} \Collect{x + 1} &= sum(X*\{x => x + 1\}) \\
&\cong Sum(Multiply(X,InfMapping(x,Add(x,1))))
\end{split}
\end{equation*}

The core task is thus in creating a representation of these ASTs. Scala provides us with a feature which is perfectly suited to this, in the form of a \textit{case class}. (In fact, Scala ASTs themselves are represented by the compiler with case classes). A case class is type of class in Scala specialised for immutable objects fully defined by their construction arguments. By default, they are compared for equality and calculate their hash value from these arguments, and not from their reference. They also enable the use of \textit{pattern-matching}, a powerful syntactic construction in Scala which will make manipulating these ASTs far easier.

\begin{figure}
\begin{lstlisting}
case class LiteralExpr[V](value: V) extends ExprNode

case class AddExpr[E1,E2](c1: E1, c2: E2) extends ExprNode

case class NegateExpr[E](c1: E) extends ExprNode

case class GroupExpr[E](c1: E) extends ExprNode

case class InfiniteMappingExpr[K,R](key: K, value: R) extends ExprNode

case class SngExpr[K,R](key: K, value: R) extends ExprNode

case class Variable(name: String) extends ExprNode

\end{lstlisting}
\caption{Signatures of expression nodes.}
\label{exprnodes}
\end{figure}

In Figure \ref{exprnodes} we present the signatures of the case classes for many of the constructs in our calculus. We omit several of the algebraic operators, as these are exactly analogous to those shown. Note that they all inherit from a common trait \lstinline{ExprNode}, and that they are polymorphic in their construction arguments, so that the compile-time type of an AST node contains the types of all of its child nodes. For example, the node:
\vs\begin{lstlisting}
AddExpr(MultiplyExpr(LiteralExpr(1),LiteralExpr(2)),LiteralExpr(3))
\end{lstlisting}\vs
will have type:
\vs\begin{lstlisting}
AddExpr[MultiplyExpr[LiteralExpr[Int],LiteralExpr[Int]],LiteralExpr[Int]]
\end{lstlisting}\vs
This will be crucial later for implementing the evaluation of these ASTs.

The other omission from the case classes shown is product types. We might have decided to create explicit case classes for product types, such as:
\vs\begin{lstlisting}
case class ExprPair[E1,E2](e1: E1, e2: E2) extends ExprNode
\end{lstlisting}\vs
However, this would lead to large amounts of code duplication, as we would have to implement a new case class for every arity of tuple we wished to support, and thus duplicate logic anywhere that these case classes were used. Instead, we will design the rest of our framework to treat products of these case classes directly as expressions, without any common inheritance, using a design pattern called a \textit{typeclass}, which will be explained in \ref{exprtypeclass}.

Additionally, we will not use native Scala tuples to represent these products. This is because Scala tuples have a different type for each arity, and so would leave us with the same problem as using case classes. To solve this, we will use Shapeless \cite{shapeless}, a generic programming library for Scala.

The key feature of shapeless is the \lstinline{HList} (or \textit{heterogenous list}), which can be thought of as a linked list in which the type of each element may be different but is known at compile time. This is implemented using the following interface:
\vs\begin{lstlisting}
trait HList
case class HCons[H,T <: HList](h: H, t: T) extends HList
case object HNil extends HList
\end{lstlisting}\vs
\lstinline{HCons} and \lstinline{HNil} act as \lstinline{Cons} and \lstinline{Nil} do in a standard Scala immutable linked list, and we can similarly use double colon (\lstinline{::}) syntax to construct HLists. But, since \lstinline{HCons} is polymorphic in both the type of its head and its tail, an \lstinline{HList} is therefore polymorphic in all of its elements. For example, we can express the tuple:
\begin{lstlisting}
(1,"a",true): (Int,String,Boolean)
\end{lstlisting}
with the equivalent HList:
\begin{lstlisting}
1::"a"::true::HNil: HCons[Int,HCons[String,HCons[Boolean,HNil]]]
\end{lstlisting}
We therefore only need to write code for \lin{HCons} and \lin{HNil} in order to support tuples of any arity. Such code will work recursively, by first applying some logic to the first element, and then recursively acting on the tail HList.

\section{Implementing natural syntax}
With the system of ASTs introduced in the previous section, we can represent any NRC query in Scala. However, directly instantiating each case class is extremely cumbersome. For example, to construct the AST for the expression: 
\begin{equation*}
\For{x}{X} \Yield{(\For{y}{x} \Collect{y+1})}
\end{equation*}
We would need to write the following code:
\vs\begin{lstlisting}
val inner = SumExpr(
  MultiplyExpr(
    Variable('x'),
    InfMapping(Variable('y'),AddExpr(Variable('y'),LiteralExpr(1))
  )
)
val expr = SumExpr(
  MultiplyExpr(
    X,InfMapping(Variable('x'),SngExpr(Variable('x'),inner))
  )
)
\end{lstlisting}\vs
In this section we describe how we implement syntax almost identical to the abstract syntax of the calculus introduced in Chapter \ref{nrc} to generate ASTs more easily.

\subsection{Operator syntax}
The first task is to implement prefix syntax for the unary operators and infix syntax for the binary operators. For example, we would like to be able to write:
\vs
\begin{lstlisting}
 -LiteralExpr(1) * LiteralExpr(2)
\end{lstlisting}
\vs
in order to construct the AST:
\vs
\begin{lstlisting}
MultiplyExpr(NegateExpr(LiteralExpr(1)),LiteralExpr(2))
\end{lstlisting}
\vs

Scala has in-built features for implementing such syntax. In the case of prefix syntax, this can be achieved for $(-)$ by implementing the method \lstinline{unary_-}, since the compiler desugars the expression \lstinline{-LiteralExpr(1)} as \lstinline{LiteralExpr(1).unary_-}.

In the case of infix syntax, this can be achieved as a result of the fact that Scala does not require the use of dots or brackets to invoke methods.  \lstinline{LiteralExpr(1) * LiteralExpr(2)} is desugared by the Scala compiler to \lstinline{LiteralExpr(1).*(LiteralExpr(2))}.

It remains to implement these methods for all ring-typed expressions. However, there is no common ancestor class for ring-typed expressions - although our explicit case classes all inherit from \lstinline{ExprNode}, products are represented as \lstinline{HList}s which clearly do not. Therefore there is no single place to implement these methods.

\subsubsection{The Expr typeclass} \label{exprtypeclass}
In Scala, to solve this problem, we can use a design pattern borrowed from Haskell called a \textit{typeclass}, and a powerful native feature called an \textit{implicit class}. The discussion in this section may seem excessive for explaining a syntactic feature, and can be skipped by readers less familiar with Scala, but the ideas introduced are used with greater significance later when implementing evaluation, so it is worth explaining them fully for this simpler use case.

A typeclass in Scala is a polymorphic trait with one type argument. For example, our expression typeclass will have the signature:
\vs \begin{lstlisting}
trait Expr[T]
\end{lstlisting} \vs
The existence of an instance of a typeclass for a type \lin{T} implies that \lin{T} can be used in a particular way, and with its methods it may implement some behaviour for type \lin{T}. This is in contrast to standard object-oriented inheritance, it which \lin{T} would have to extend an \lin{Expr} trait directly. Then, when we wish to write a method operating on \lin{Expr}-compatible objects, we write the signature as follows:
\vs \begin{lstlisting}
def foo[E](e: E)(implicit expr: Expr[E]) =  { ... }
\end{lstlisting} \vs
We can use a similar pattern for a construction argument of a class:
\vs \begin{lstlisting}
class Foo[E](e: E)(implicit expr: Expr[E]) { ... }
\end{lstlisting} \vs

These signatures will accept an argument of any type \lin{E}, as long as they are also provided with a value of type \lin{Expr[E]} for the parameter \lin{expr}. But, because \lin{expr} is marked with the keyword \lin{implicit}, the compiler can do this automatically using a process called \textit{implicit resolution}. Implicit resolution is a compilation stage in which the compiler identifies implicit parameters which have not been provided at the call site. Where these occur, the compiler will search for methods also marked \textit{implicit} which return the type of the omitted implicit parameter. These methods may themselves have implicit parameters, and so the process continues recursively.

Hence, if we write a set of implicit methods which generate instances of \lin{Expr} for all valid expression types, then we can call the method \lin{foo} for any valid expression without providing the instance of \lin{Expr} explicitly.

Therefore we must first provide an implicit method which generates an instance of \lin{Expr[T]} for any \lin{T} which is one of our explicit AST operator nodes:
\vs\begin{lstlisting}
implicit def ExprNode[E <: ExprNode]: Expr[E] = new Expr[E] {}
\end{lstlisting} \vs
And we also provide implicit methods to recursively generate instances for \lin{HList}s consisting of elements which themselves have instances of \lin{Expr}:
\vs\begin{lstlisting}
implicit def HNilExpr: Expr[HNil] = new Expr[HNil] {}

implicit def HConsExpr[H,T <: HList]
  (implicit exprH: Expr[H],
   exprT: Expr[T]): Expr[H::T] = new Expr[H::T] {}
\end{lstlisting}\vs
It is important to recognise that this is an encoding of the inductive rules which define a valid expression: The base case is that the expression is either an \lin{ExprNode} or an \lin{HNil} (i.e. the empty product). The fact that these are the base cases can be seen by noting that the implicit methods to generate Expr instances for these types do not take any parameters themselves - the compiler can directly invoke them for these types. Then, the inductive case is that the expression is an \lin{HList} consisting of valid \lin{Expr} elements. This can be seen by noting that, for product types, the compiler can only create an \lin{Expr} instance for them if it can recursively create \lin{Expr} instances for both the head type and tail types in order to provide the implicit parameters of the method \lin{HConsExpr}.

Later, we will use this ability to encode inductive rules in a system of implicit methods to great effect when we use it to automatically generate implementations of algebraic operators for types of arbitrary complexity.

\vs Unfortunately, we cannot directly implement the operators in the \lin{Expr} typeclass, as then they only be available to instances of \lin{Expr[T]} and not the expressions themselves. Instead, we will use an \textit{implicit class}.

An implicit class is like a regular class, except it can only have one explicit construction argument, say of type \lin{T}. The existence of such an implicit class then allows its methods to be used as though they are methods of the type \lin{T}. This happens at compile-time. When the compiler finds method invocations which do not correspond to methods directly available to the object in question, it searches for an implicit class which can be instantiated using the object as the construction argument. If such an implicit class exists and contains a matching method, the object will be translated into an instance of the implicit class.
For example, suppose the compiler encounters the statement \lin{foo.bar(baz)} where \lin{foo: Foo, bar: Bar, baz: Baz}, and that neither the class \lin{Foo} nor any of its ancestors contains a method \lin{bar}. However, suppose the following implicit class is in scope:
\vs\begin{lstlisting}
implicit class FooImplicits(foo: Foo) {
  def bar(baz: Baz) = ...
}
\end{lstlisting}\vs
Then the compiler will translate the statement \lin{foo.bar(baz)} into \lin{(new FooImplicits(foo)).bar(baz)}. This is commonly used to add methods to private classes, but can also be used to provide methods to all types conforming to some typeclass, by additionally requiring an instance of the typeclass implicitly to construct the implicit class. Our implicit class will thus be:
\vs \begin{lstlisting}
implicit class ExprOps[T](e: Expr)(implicit expr: Expr[T]) {
  def unary_- = NegateExpr(e)
  def +[T1](e1: T1)(implicit expr1: Expr[T1]) = AddExpr(e, e1)
  ...
}
\end{lstlisting} \vs
Thus, objects will only be able to access these methods if they are of some type \lin{T} for which an instance of \lin{Expr[T]} can be provided implicitly, i.e. they are a valid expression type.

We also use this typeclass to provide shorthand construction methods for \lin{SngExpr}, \lin{GroupExpr} and \lin{SumExpr}, for example:
\begin{lstlisting}
def Sng[K:Expr, R:Expr](k: K, r: R): SngExpr[K, R] = SngExpr(k, r)
\end{lstlisting}

%We now illustrate the steps taken by the compiler to translate \lin{-LiteralExpr(1) * LiteralExpr(2)} into \lin{MultiplyExpr(NegateExpr(LiteralExpr(1)),LiteralExpr(2))}. First, it is desugared as previously described to:
%\vs\begin{lstlisting}
%(LiteralExpr(1).unary_-).*(LiteralExpr(2))
%\end{lstlisting}\vs
%Then, since the methods \lin{unary_-} is not directly accessible from \lin{LiteralExpr}, \lin{LiteralExpr(1).unary_-} is translated into \lin{(new ExprOps(LiteralExpr(1))).negate} which equals \%lin{NegateExpr(LiteralExpr(1))}. Similarly, since the method 

\subsection{For-comprehension syntax}

Next we would like to be able to use the for/yield and for/collect comprehensions introduced in Chapter \ref{nrc}. We only provide a brief overview of this implementation as it uses more standard Scala features which are of less theoretical interest.

Although \textit{for} and \textit{yield} are reserved keywords in Scala, we can use their capitalised versions. Therefore, we would like the following expressions to be valid and generate the corresponding ASTs:

\vs \begin{lstlisting}
val forCollect = For (Variable('x') <- X) Collect r
val forCollectAst = SumExpr(
  MultiplyExpr(X,InfiniteMappingExpr(Variable('x'), r))
)

val forYield = For (Variable('x') <-- X) Yield k --> r 
val forYieldAst = SumExpr(
  MultiplyExpr(X,InfiniteMappingExpr(Variable('x'),SngExpr(k,r)))
)
\end{lstlisting} \vs

To understand how such syntax can be implemented within Scala, we will use example of the for/collect comprehension. The above value \textit{forCollect} is desugared as:
\vs \begin{lstlisting}
For.(Variable('x').<--(X)).Collect(r)
\end{lstlisting}\vs
Therefore, we need to implement:
\begin{itemize}
\item{The \lin{<--} method for variables, which pairs them with an expression \lin{X} representing a finite collection.}
\item{A class  \textit{For}, which is constructed with one of these variable/collection pairs. \textit{For} needs additionally a method \textit{Collect}, which takes a ring-typed expression and constructs the AST:
\vs\begin{lstlisting}
SumExpr(MultiplyExpr(X,InfiniteMappingExpr(v,r)))
\end{lstlisting}\vs
Where X is the collection passed to the instance of \textit{For} at construction, \textit{v} is the variable passed to \textit{For}, and \textit{r} is the ring-typed expression passed to the \textit{Collect} method.
}
\end{itemize}

The full details are included in Appendix \ref{codebase} in the file \textit{Syntax.scala}.

\subsection{Implicit conversion of literal values}

Finally, we would like to be able to use certain literal values, such as integers and booleans, in our DSL without explicitly initialising \lin{LiteralExpr} nodes. We would also like to be able to use the more natural tuple syntax instead of constructing product types with \lin{HList} syntax. This will allow us to write, for example:
\vs\begin{lstlisting}
(1,1) dot (2,2)
\end{lstlisting}\vs
And have this Scala expression generate the AST:
\vs\begin{lstlisting}
DotExpr(LiteralExpr(1)::LiteralExpr(1)::HNil, LiteralExpr(2)::LiteralExpr(2)::HNil).
\end{lstlisting}\vs
As there is, for example, a one-to-one correspondence between integers, and literal expressions contains integers, or between tuples and \lin{HList}s, this is straightforward to implement with Scala's implicit conversions. The full implementation is again in Appendix \ref{codebase} in the file \textit{Syntax.scala}.
\section{Example usage}
We will demonstrate the usage of the DSL by writing the query from the introduction, which we expressed in the calculus in Section \ref{examplequery}. First we turn the RDDs into instances of \lin{LiteralExpr}. This will involve ensuring each is an RDD of a pair, where the first element is the key and the second element the value. Tuples within either the key or value must be translated into HLists:
\begin{lstlisting}
val ratingsRdd: RDD[(Track,Date,Int)]
val ratingsCollection = LiteralExpr(
  ratingsRdd.map { case (track,date,value) =>
    ((track::date::HNil),value)
  }
)

val trackArtistsRdd: RDD[(Track,Artist)]
val trackArtistsCollection = LiteralExpr(
  ratingsCollection.map { case (track,artist) =>
    (track::artist::HNil,1)
  }
)
\end{lstlisting}
Then we set up the variables to be used in the query, making sure to give each a unique string name:
\begin{lstlisting}
val user = Variable("user")
val track = Variable("track")
...
\end{lstlisting} 
Finally, we can proceed nearly identically to the abstract query:
\begin{lstlisting}
val trackRatings = Group(
  For ((user,track,date) <-- ratings) Yield (track,date)
)
val artistTrackRatingsFlat = trackArtists.join(trackRatingsByDate)
val artistTrackRatings = Group(
  For (((track,(artist,ratings)) <-- artistTrackRatingsFlat)
  Yield (artist,(track,ratings))
)
\end{lstlisting}

